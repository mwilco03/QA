/**
 * LMS QA Validator v6.1.0
 * Built: 2026-01-13T16:29:23.864Z
 *
 * Modular source in /src - DO NOT EDIT THIS FILE DIRECTLY
 * Run 'npm run build' to regenerate from source modules.
 */
(function () {
    'use strict';

    /**
     * Constants - Single source of truth for all configuration values
     *
     * IMPORTANT: This is the ONE place where these values are defined.
     * All modules import from here. No copy-paste. No drift.
     */

    const VERSION = '6.1.0';

    // Runtime configuration
    const CONFIG = Object.freeze({
        MAX_RECURSION_DEPTH: 20,
        MAX_API_SEARCH_DEPTH: 5,
        MAX_FETCH_TIMEOUT: 5000,
        MAX_RESOURCES: 100,
        MAX_LOGS: 500,
        DEBOUNCE_DELAY: 150
    });

    // Path patterns - Centralized configuration for authoring tool detection
    // These patterns may vary by tool version; update HERE when new patterns are found
    const PATHS = Object.freeze({
        STORYLINE: {
            DETECT_PATTERNS: [
                /\/html5\/data\/js\//,
                /\/story_content\//,
                /\/mobile\/data\//
            ],
            DATA_FILES: ['data.js', 'frame.js', 'paths.js', 'text.js', 'textdata.js'],
            DATA_JS_PATH: '/html5/data/js',
            SLIDE_ID_PATTERN: /^[0-9a-zA-Z]{11}$/
        },
        TLA: {
            TASKS_ENDPOINT: '/api/assets/tasks.json',
            STATE_ENDPOINT: '/api/sessions/{sessionId}/lrs/state',
            SCORE_ENDPOINT: '/api/sessions/{sessionId}/score',
            SESSION_ID_PATTERN: /sessions?\/([a-z]{2}-[0-9a-f-]+)/i
        },
        ISPRING: {
            DATA_FILES: ['data.js', 'slides.js', 'quiz.js']
        },
        CAPTIVATE: {
            DATA_FILES: ['quiz.js', 'project.js']
        },
        LECTORA: {
            DATA_FILES: ['a001index.html', 'trivantis.js']
        }
    });

    // Item types for extracted content
    const ITEM_TYPE = Object.freeze({
        QUESTION: 'question',
        ANSWER: 'answer',
        SEQUENCE: 'sequence_item',
        DRAG: 'drag_item',
        DROP: 'drop_target',
        MATCH_SOURCE: 'match_source',
        MATCH_TARGET: 'match_target'
    });

    // Authoring tool identifiers
    const AUTHORING_TOOL = Object.freeze({
        STORYLINE: 'storyline',
        RISE: 'rise',
        CAPTIVATE: 'captivate',
        LECTORA: 'lectora',
        ISPRING: 'ispring',
        CAMTASIA: 'camtasia',
        GENERIC: 'generic'
    });

    // Correct answer indicators
    const CORRECT_INDICATORS = Object.freeze({
        VALUES: ['true', 'correct', '1'],
        DATA_ATTRS: ['correct', 'answer', 'right'],
        CLASSES: ['correct', 'right-answer', 'is-correct']
    });

    // Placeholder text to ignore
    const PLACEHOLDER_TEXT = Object.freeze([
        'choose...', 'select...', 'select one', 'select an option',
        '---', '- select -', ''
    ]);

    // Message types for extension communication
    const MSG = Object.freeze({
        PREFIX: 'LMS_QA_',
        READY: 'READY',
        SCAN_STARTED: 'SCAN_STARTED',
        SCAN_COMPLETE: 'SCAN_COMPLETE',
        SCAN_ERROR: 'SCAN_ERROR',
        PROGRESS: 'PROGRESS',
        STATE: 'STATE',
        CMI_DATA: 'CMI_DATA',
        TEST_RESULT: 'TEST_RESULT',
        SET_COMPLETION_RESULT: 'SET_COMPLETION_RESULT',
        FORCE_COMPLETION_RESULT: 'FORCE_COMPLETION_RESULT',
        AUTO_SELECT_RESULT: 'AUTO_SELECT_RESULT',
        OBJECTIVES_COMPLETE: 'OBJECTIVES_COMPLETE',
        SLIDES_MARKED: 'SLIDES_MARKED',
        FULL_COMPLETION_RESULT: 'FULL_COMPLETION_RESULT',
        DURATION_ESTIMATE: 'DURATION_ESTIMATE',
        COMPLETION_REQUEST_DETECTED: 'COMPLETION_REQUEST_DETECTED',
        NETWORK_ANALYSIS: 'NETWORK_ANALYSIS',
        REPLAY_RESULT: 'REPLAY_RESULT',
        // Commands
        CMD_SCAN: 'LMS_QA_CMD_SCAN',
        CMD_TEST_API: 'LMS_QA_CMD_TEST_API',
        CMD_SET_COMPLETION: 'LMS_QA_CMD_SET_COMPLETION',
        CMD_FORCE_COMPLETION: 'LMS_QA_CMD_FORCE_COMPLETION',
        CMD_COMPLETE_OBJECTIVES: 'LMS_QA_CMD_COMPLETE_OBJECTIVES',
        CMD_MARK_SLIDES: 'LMS_QA_CMD_MARK_SLIDES',
        CMD_FULL_COMPLETION: 'LMS_QA_CMD_FULL_COMPLETION',
        CMD_ESTIMATE_DURATION: 'LMS_QA_CMD_ESTIMATE_DURATION',
        CMD_START_NETWORK_MONITOR: 'LMS_QA_CMD_START_NETWORK_MONITOR',
        CMD_STOP_NETWORK_MONITOR: 'LMS_QA_CMD_STOP_NETWORK_MONITOR',
        CMD_GET_NETWORK_ANALYSIS: 'LMS_QA_CMD_GET_NETWORK_ANALYSIS',
        CMD_REPLAY_COMPLETION: 'LMS_QA_CMD_REPLAY_COMPLETION',
        CMD_GET_STATE: 'LMS_QA_CMD_GET_STATE',
        CMD_GET_CMI_DATA: 'LMS_QA_CMD_GET_CMI_DATA',
        CMD_AUTO_SELECT: 'LMS_QA_CMD_AUTO_SELECT',
        CMD_EXPORT: 'LMS_QA_CMD_EXPORT',
        CMD_DETECT_APIS: 'LMS_QA_CMD_DETECT_APIS',
        CMD_SEED_EXTRACT: 'LMS_QA_CMD_SEED_EXTRACT',
        APIS_DETECTED: 'APIS_DETECTED',
        SEED_EXTRACT_RESULT: 'SEED_EXTRACT_RESULT'
    });

    // Code detection patterns - used to filter out code from content extraction
    const CODE_INDICATORS = Object.freeze([
        /[{}\[\]();].*[{}\[\]();]/,
        /\bfunction\s*\(/,
        /\bvar\s+\w+\s*=/,
        /\bconst\s+\w+\s*=/,
        /\blet\s+\w+\s*=/,
        /\breturn\s+[\w.]+[({]/,
        /\bif\s*\([^)]+\)\s*{/,
        /\bfor\s*\([^)]+\)/,
        /\bwhile\s*\(/,
        /\bthis\.\w+\(/,
        /\w+\.\w+\.\w+\(/,
        /=>\s*{/,
        /\w+\s*===?\s*\w+/,
        /\w+\s*!==?\s*\w+/,
        /\|\||&&/,
        /\+\+|--/,
        /\w+\[\w+\]/,
        /parseInt|parseFloat|toString/,
        /null|undefined|NaN/,
        /\.length\s*[><=]/,
        /\.push\(|\.pop\(|\.shift\(/,
        /\.map\(|\.filter\(|\.reduce\(/,
        /\.substr\(|\.substring\(/,
        /console\.|window\.|document\./,
        /[a-z]+[A-Z][a-z]+[A-Z]/,
        /^[a-z]+[A-Z]/,
        /\b(str|int|bln|ary|obj)[A-Z]/
    ]);

    /**
     * State Management Module
     *
     * Centralized state with event-based change notification.
     * Single source of truth for runtime state.
     */

    const state = {
        apis: [],
        resources: [],
        qa: [],
        logs: [],
        warnings: [],
        scanning: false,
        lastScan: null
    };

    const listeners = new Map();

    function emit(event, data) {
        const handlers = listeners.get(event) || [];
        handlers.forEach(fn => {
            try {
                fn(data);
            } catch (e) {
                console.error(`[LMS QA] Event handler error for ${event}:`, e);
            }
        });
    }

    const StateManager = {
        get(key) {
            return key ? state[key] : { ...state };
        },

        set(key, value) {
            const oldValue = state[key];
            state[key] = value;
            emit('change', { key, value, oldValue });
            emit(`change:${key}`, { value, oldValue });
        },

        append(key, item) {
            if (Array.isArray(state[key])) {
                state[key].push(item);
                emit(`append:${key}`, item);
            }
        },

        reset() {
            state.apis = [];
            state.resources = [];
            state.qa = [];
            state.logs = [];
            state.warnings = [];
            state.scanning = false;
            emit('reset');
        },

        on(event, handler) {
            if (!listeners.has(event)) {
                listeners.set(event, []);
            }
            listeners.get(event).push(handler);
            return () => this.off(event, handler);
        },

        off(event, handler) {
            const handlers = listeners.get(event);
            if (handlers) {
                const idx = handlers.indexOf(handler);
                if (idx > -1) handlers.splice(idx, 1);
            }
        }
    };

    /**
     * Logger Module
     *
     * Centralized logging with level filtering and state integration.
     */


    const LOG_LEVEL = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3 };
    let currentLevel = LOG_LEVEL.INFO;

    function formatEntry(level, message, data) {
        return {
            timestamp: new Date().toISOString(),
            level,
            message,
            data: data ? JSON.parse(JSON.stringify(data)) : undefined
        };
    }

    function log(level, levelName, message, data) {
        if (level < currentLevel) return;

        const entry = formatEntry(levelName, message, data);
        StateManager.append('logs', entry);

        const logs = StateManager.get('logs');
        if (logs.length > CONFIG.MAX_LOGS) {
            StateManager.set('logs', logs.slice(-CONFIG.MAX_LOGS));
        }

        const consoleMethod = levelName === 'ERROR' ? 'error' :
                              levelName === 'WARN' ? 'warn' : 'log';
        if (data) {
            console[consoleMethod](`[LMS QA] ${message}`, data);
        } else {
            console[consoleMethod](`[LMS QA] ${message}`);
        }

        return entry;
    }

    const Logger = {
        debug: (msg, data) => log(LOG_LEVEL.DEBUG, 'DEBUG', msg, data),
        info: (msg, data) => log(LOG_LEVEL.INFO, 'INFO', msg, data),
        warn: (msg, data) => log(LOG_LEVEL.WARN, 'WARN', msg, data),
        error: (msg, data) => log(LOG_LEVEL.ERROR, 'ERROR', msg, data),

        setLevel(level) {
            currentLevel = LOG_LEVEL[level] ?? LOG_LEVEL.INFO;
        },

        getLogs() {
            return StateManager.get('logs');
        },

        time(label) {
            const start = performance.now();
            return () => {
                const duration = performance.now() - start;
                this.debug(`${label}: ${duration.toFixed(2)}ms`);
                return duration;
            };
        }
    };

    /**
     * Utilities Module
     *
     * Shared utility functions used across all modules.
     * Import what you need - no more copy-paste.
     */


    const Utils = {
        matchesAny(value, patterns) {
            if (!value) return false;
            const normalized = String(value).toLowerCase().trim();
            return patterns.some(p => normalized === p.toLowerCase());
        },

        /**
         * Check if text looks like code rather than natural language content
         */
        isCodeLike(text) {
            if (!text || text.length < 5) return true;

            for (const pattern of CODE_INDICATORS) {
                if (pattern.test(text)) {
                    return true;
                }
            }

            const codeCharCount = (text.match(/[{}\[\]();=<>!&|+\-*\/]/g) || []).length;
            const codeCharRatio = codeCharCount / text.length;
            if (codeCharRatio > 0.15) return true;

            const words = text.split(/\s+/);
            const avgWordLength = words.reduce((sum, w) => sum + w.length, 0) / words.length;
            if (avgWordLength < 3 && words.length > 3) return true;

            if (/^[a-z]+[A-Z]/.test(text) && !text.includes(' ')) return true;

            return false;
        },

        /**
         * Check if text looks like natural language content
         */
        isNaturalLanguage(text) {
            if (!text || text.length < 10) return false;
            if (!text.includes(' ')) return false;
            if (!/^[A-Z0-9]/.test(text.trim())) return false;

            const words = text.trim().split(/\s+/);
            if (words.length < 2) return false;

            const avgLen = words.reduce((s, w) => s + w.length, 0) / words.length;
            if (avgLen < 2 || avgLen > 15) return false;

            return !Utils.isCodeLike(text);
        },

        isCorrectAnswer(element) {
            if (!element) return false;

            const value = element.value || element.getAttribute('value');
            if (Utils.matchesAny(value, CORRECT_INDICATORS.VALUES)) {
                return true;
            }

            for (const attr of CORRECT_INDICATORS.DATA_ATTRS) {
                if (element.dataset?.[attr] === 'true' ||
                    element.getAttribute(`data-${attr}`) === 'true') {
                    return true;
                }
            }

            if (element.classList) {
                for (const cls of CORRECT_INDICATORS.CLASSES) {
                    if (element.classList.contains(cls)) {
                        return true;
                    }
                }
            }

            return false;
        },

        isPlaceholder(text) {
            if (!text) return true;
            return Utils.matchesAny(text.trim(), PLACEHOLDER_TEXT);
        },

        safeJsonParse(str, defaultValue = null) {
            try {
                return JSON.parse(str);
            } catch {
                return defaultValue;
            }
        },

        escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },

        generateId(prefix = '') {
            const random = Math.random().toString(36).substring(2, 8);
            return prefix ? `${prefix}-${random}` : random;
        },

        truncate(str, maxLength = 100) {
            if (!str || str.length <= maxLength) return str;
            return str.substring(0, maxLength - 3) + '...';
        },

        async fetchWithTimeout(url, timeout = CONFIG.MAX_FETCH_TIMEOUT) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            try {
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    throw new Error(`Request timeout: ${url}`);
                }
                throw error;
            }
        },

        isSameOrigin(url) {
            try {
                const parsed = new URL(url, window.location.href);
                return parsed.origin === window.location.origin;
            } catch {
                return false;
            }
        },

        dedupeBy(array, keyFn) {
            const seen = new Set();
            return array.filter(item => {
                const key = keyFn(item);
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
        },

        /**
         * Detect compression type in suspend_data
         */
        detectCompression(data) {
            if (!data || typeof data !== 'string') return null;

            if (data.startsWith('H4sI')) return 'gzip';

            if (data.startsWith('[') && /^\[\d+(?:,\d+)*\]$/.test(data.substring(0, 100))) {
                try {
                    const arr = JSON.parse(data);
                    if (Array.isArray(arr) && arr.length > 0 && arr.every(n => typeof n === 'number')) {
                        return 'lzw';
                    }
                } catch {}
            }

            if (data.length >= 50 && /^[A-Za-z0-9+/=]+$/.test(data) && !data.includes(' ')) {
                if (data.length > 100) return 'base64';
            }

            if (data.length > 100 && !/[aeiou]{3,}/i.test(data) && /^[A-Za-z0-9+/=_-]+$/.test(data)) {
                return 'storyline-custom';
            }

            return null;
        },

        /**
         * Base64 decode with error handling
         */
        base64Decode(str) {
            try {
                return atob(str);
            } catch (e) {
                Logger.debug('Base64 decode failed', e);
                return null;
            }
        },

        /**
         * Base64 encode
         */
        base64Encode(str) {
            try {
                return btoa(str);
            } catch (e) {
                Logger.debug('Base64 encode failed', e);
                return null;
            }
        }
    };

    /**
     * Messenger Module
     *
     * Handles communication between page context and extension.
     * Uses window.postMessage for cross-context messaging.
     */


    const Messenger = {
        /**
         * Send message to extension
         * @param {string} type - Message type from MSG constants
         * @param {*} payload - Message payload
         */
        send(type, payload) {
            window.postMessage({
                type: MSG.PREFIX + type,
                payload,
                source: 'lms-qa-validator',
                version: VERSION
            }, '*');
        },

        /**
         * Listen for commands from extension
         * @param {Function} handler - Handler function(type, payload)
         */
        listen(handler) {
            window.addEventListener('message', (event) => {
                if (event.source !== window) return;

                const { type, payload } = event.data || {};
                if (!type) return;

                // Handle commands
                if (type.startsWith('LMS_QA_CMD_')) {
                    Logger.debug(`Received command: ${type}`, payload);
                    handler(type, payload);
                }
            });
        }
    };

    /**
     * Base Extractor
     *
     * Common interface all extractors must implement.
     * This ensures consistency and allows the registry to work with any extractor.
     */


    /**
     * Create an extractor with standard interface
     * @param {Object} config - Extractor configuration
     * @param {string} config.toolId - Unique identifier (from AUTHORING_TOOL)
     * @param {Function} config.detect - Returns true if this extractor should handle the page
     * @param {Function} config.extract - Extracts Q&A items, returns array
     * @param {Function} [config.getInfo] - Optional: returns tool-specific info
     */
    function createExtractor({ toolId, detect, extract, getInfo }) {
        return {
            toolId,

            /**
             * Detect if this extractor should handle current page
             * @returns {boolean}
             */
            detect() {
                try {
                    return detect();
                } catch (e) {
                    Logger.debug(`${toolId} detection error: ${e.message}`);
                    return false;
                }
            },

            /**
             * Extract Q&A items from page
             * @returns {Promise<Array>} Array of extracted items
             */
            async extract() {
                try {
                    Logger.info(`Running ${toolId} extractor`);
                    const items = await extract();
                    Logger.info(`${toolId} extracted ${items.length} items`);
                    return items;
                } catch (e) {
                    Logger.error(`${toolId} extraction error: ${e.message}`);
                    return [];
                }
            },

            /**
             * Get tool-specific information
             * @returns {Object|null}
             */
            getInfo() {
                if (getInfo) {
                    try {
                        return getInfo();
                    } catch (e) {
                        Logger.debug(`${toolId} getInfo error: ${e.message}`);
                    }
                }
                return null;
            }
        };
    }

    /**
     * Extractor Registry
     *
     * Central registry for all content extractors.
     * Handles detection and routing to appropriate extractor.
     */


    const extractors = new Map();

    const ExtractorRegistry = {
        /**
         * Register an extractor
         * @param {Object} extractor - Extractor instance with detect/extract methods
         */
        register(extractor) {
            if (!extractor.toolId) {
                throw new Error('Extractor must have toolId');
            }
            extractors.set(extractor.toolId, extractor);
            Logger.debug(`Registered extractor: ${extractor.toolId}`);
        },

        /**
         * Get extractor by tool ID
         * @param {string} toolId
         * @returns {Object|null}
         */
        get(toolId) {
            return extractors.get(toolId) || null;
        },

        /**
         * Detect which extractor(s) can handle current page
         * @returns {Array<Object>} Array of matching extractors
         */
        detectAll() {
            const matches = [];
            for (const [id, extractor] of extractors) {
                if (extractor.detect()) {
                    matches.push(extractor);
                }
            }
            return matches;
        },

        /**
         * Detect primary extractor for current page
         * @returns {Object|null}
         */
        detectPrimary() {
            // Check in order of specificity
            const priority = [
                AUTHORING_TOOL.STORYLINE,
                AUTHORING_TOOL.RISE,
                AUTHORING_TOOL.CAPTIVATE,
                AUTHORING_TOOL.LECTORA,
                AUTHORING_TOOL.ISPRING,
                AUTHORING_TOOL.GENERIC
            ];

            for (const toolId of priority) {
                const extractor = extractors.get(toolId);
                if (extractor?.detect()) {
                    return extractor;
                }
            }

            return null;
        },

        /**
         * Run all matching extractors and combine results
         * @returns {Promise<Array>} Combined extraction results
         */
        async extractAll() {
            const matches = this.detectAll();
            Logger.info(`Found ${matches.length} matching extractors`);

            const results = [];
            for (const extractor of matches) {
                const items = await extractor.extract();
                results.push(...items);
            }

            return results;
        },

        /**
         * Get list of registered extractor IDs
         * @returns {Array<string>}
         */
        list() {
            return Array.from(extractors.keys());
        }
    };

    /**
     * LMS QA Validator - Main Entry Point
     *
     * This is the entry point for the bundler.
     * All modules are imported and assembled here.
     *
     * Architecture:
     * - /core: Constants, state, logging, utilities (shared by all)
     * - /extractors: Tool-specific content extractors
     * - /api: SCORM/xAPI detection and completion
     * - /network: Request interception and analysis
     * - messenger.js: Extension communication
     */


    // Prevent double injection
    if (window.__LMS_QA_INJECTED__) {
        console.log('[LMS QA] Already injected, skipping');
    } else {
        window.__LMS_QA_INJECTED__ = true;

        // ═══════════════════════════════════════════════════════════════════════════
        // INITIALIZATION
        // ═══════════════════════════════════════════════════════════════════════════

        Logger.info(`LMS QA Validator v${VERSION} initializing`);

        // ═══════════════════════════════════════════════════════════════════════════
        // REGISTER EXTRACTORS
        // TODO: These will be imported from separate files as they're migrated
        // ═══════════════════════════════════════════════════════════════════════════

        // Storyline Extractor (placeholder - full implementation to be migrated)
        ExtractorRegistry.register(createExtractor({
            toolId: AUTHORING_TOOL.STORYLINE,
            detect: () => !!(
                window.DS ||
                window.globalProvideData ||
                window.g_slideData ||
                window.player ||
                document.querySelector('[data-acc-type]')
            ),
            extract: async () => {
                // TODO: Migrate full Storyline extraction logic
                Logger.info('Storyline extractor running (modular version)');
                const items = [];

                // Basic DS extraction
                if (window.DS?.VO) {
                    for (const [id, obj] of Object.entries(window.DS.VO)) {
                        if (obj.accType && ['radiobutton', 'checkbox'].includes(obj.accType)) {
                            items.push({
                                type: ITEM_TYPE.ANSWER,
                                text: obj.accText || obj.rawText || '',
                                source: 'storyline:DS',
                                id
                            });
                        }
                    }
                }

                return items;
            },
            getInfo: () => ({
                hasDS: !!window.DS,
                hasGlobalProvideData: typeof window.globalProvideData === 'function',
                hasPlayer: !!window.player
            })
        }));

        // Generic DOM Extractor
        ExtractorRegistry.register(createExtractor({
            toolId: AUTHORING_TOOL.GENERIC,
            detect: () => true, // Always available as fallback
            extract: async () => {
                const items = [];
                // Extract from form elements
                document.querySelectorAll('input[type="radio"], input[type="checkbox"]').forEach(el => {
                    const label = document.querySelector(`label[for="${el.id}"]`);
                    if (label) {
                        items.push({
                            type: ITEM_TYPE.ANSWER,
                            text: label.textContent.trim(),
                            correct: Utils.isCorrectAnswer(el),
                            source: 'generic:form'
                        });
                    }
                });
                return items;
            }
        }));

        // ═══════════════════════════════════════════════════════════════════════════
        // COMMAND HANDLER
        // ═══════════════════════════════════════════════════════════════════════════

        Messenger.listen(async (type, payload) => {
            switch (type) {
                case MSG.CMD_SCAN:
                    StateManager.set('scanning', true);
                    Messenger.send(MSG.SCAN_STARTED, {});
                    try {
                        const items = await ExtractorRegistry.extractAll();
                        StateManager.set('qa', items);
                        Messenger.send(MSG.SCAN_COMPLETE, {
                            items,
                            count: items.length
                        });
                    } catch (e) {
                        Messenger.send(MSG.SCAN_ERROR, { error: e.message });
                    } finally {
                        StateManager.set('scanning', false);
                    }
                    break;

                case MSG.CMD_GET_STATE:
                    Messenger.send(MSG.STATE, StateManager.get());
                    break;

                // TODO: Migrate remaining command handlers
                default:
                    Logger.debug(`Unhandled command: ${type}`);
            }
        });

        // ═══════════════════════════════════════════════════════════════════════════
        // PUBLIC API
        // ═══════════════════════════════════════════════════════════════════════════

        window.LMS_QA = {
            version: VERSION,
            getState: () => StateManager.get(),
            getQA: () => StateManager.get('qa'),
            scan: async () => {
                const items = await ExtractorRegistry.extractAll();
                StateManager.set('qa', items);
                return items;
            },
            getAPIs: () => StateManager.get('apis'),
            getLogs: () => Logger.getLogs(),

            // Expose internals for debugging
            _debug: {
                StateManager,
                Logger,
                Utils,
                ExtractorRegistry,
                CONFIG,
                PATHS
            }
        };

        // ═══════════════════════════════════════════════════════════════════════════
        // READY
        // ═══════════════════════════════════════════════════════════════════════════

        Messenger.send(MSG.READY, { version: VERSION, url: window.location.href });
        Logger.info(`Ready. Use window.LMS_QA to interact.`);
    }

})();
//# sourceMappingURL=lms-qa-validator.js.map
